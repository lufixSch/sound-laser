\subsection{SPI (Audio Output)}

\subsubsection*{SPI Interface}

As described before the sampling rate of the SPI output should be at least $100\,kHz$. This means every $10\,\mu s$ one packet has to be submitted. The Linux OS for the Raspberry Pi provides a SPI implementation which can be accessed via C++ or Python. After putting the SPI write function into a loop without any pause or other calculations in between it became noticeable that this implementation is only able to send one package every $50\,\mu s$ to $80\,\mu s$. This problem can be solved with the \textbf{bcm2835} C library.\cite{mccauley_bcm2835_nodate} This library bypasses the linux drivers and directly accesses the bcm2835 SOC from the Raspberry Pi. It provides interfaces for GPIO pins, PWM and SPI as well as \lstcpp{bcm2835_delayMicroseconds()} function which is much more accurate than the builtin C++ functions.\p
%
The SPI configuration is put into the HAL class \lstcpp{SPI} (See listing \ref{lst:software:spi:conf})
%
\begin{mdframed}
\begin{lstlisting}[caption=SPI configuration, label=lst:software:spi:conf]
SPI::SPI() {
  if (!bcm2835_spi_begin()) {
    throw std::runtime_error("bcm2835_spi_begin failed. Are you running as root??");
  }

  bcm2835_spi_setBitOrder(BCM2835_SPI_BIT_ORDER_MSBFIRST);
  bcm2835_spi_setDataMode(BCM2835_SPI_MODE0);
  bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_64);
  bcm2835_spi_chipSelect(BCM2835_SPI_CS0);
  bcm2835_spi_setChipSelectPolarity(BCM2835_SPI_CS0, LOW);
}
\end{lstlisting}
\end{mdframed}
%
The \lstcpp{SPI} class provides the method \lstcpp{write()} which takes a byte array and writes it on the SPI bus (Listing \ref{lst:software:spi:write}). \lstcpp{write()} uses the method \lstcpp{transfer()} which passes through the function \lstcpp{bcm2835_spi_transfernb()} from the \textbf{bcm2835} library. This function needs two buffers. One contains the data to be transmitted. The second one is used to save the received data.
%
\begin{mdframed}
\begin{lstlisting}[caption=Method for writing data onto the SPI bus, label=lst:software:spi:write]
void SPI::write(char* data, uint32_t size) {
  this->transfer(data, this->rx_buffer, size);
}
\end{lstlisting}
\end{mdframed}
%
\lstcpp{rx_buffer} is a $4096$ Byte array where the unused, received data from the \lstcpp{write()} method is dumped.
%
\subsubsection*{Transmit Audio}

The audio transmission over SPI is performed in the class \lstcpp{Speaker}. The method \lstcpp{Speaker::run()} creates a loop in which the next audio sample is fetched from the \lstcpp{Speaker::samples} queue and transmitted over SPI. After the transmission the loop is paused to reach the right sampling rate. The sleep time is calculated dynamically depending on the time the sending of the data took. The coresponding code is shown in listing \ref{lst:software:spi:loop}.
\begin{figure}[ht]
\begin{mdframed}
\begin{lstlisting}[caption=Audio transmission loop, label=lst:software:spi:loop]
void Speaker::run() {
  std::cout << "Run Speaker Loop with a max delay of " << delay << "\n";

  long long diff;
  uint64_t delay = (uint64_t)(1000000000 / sampling_rate);
  char data[WORD_SIZE] = { conf, 0x00, 0x00 };
  auto start = std::chrono::high_resolution_clock::now();

  while (true) {
    auto sample = samples.pop();
    data[1] = (char)(sample >> 4);
    data[2] = (char)((sample & 0x000F) << 4);

    spi.write(data, WORD_SIZE);

    auto diff = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - start)
                    .count();
    auto diff_abs = (uint64_t)diff <= delay ? diff : delay;
    auto sleep = (delay - diff_abs) / 1000;

    bcm2835_delayMicroseconds(sleep);
    start = std::chrono::high_resolution_clock::now();
  }
}
\end{lstlisting}
\end{mdframed}
\end{figure}
%
\subsubsection*{Linux Realtime}

Because the signal is split into a fixed sampling rate, timing is really important for this task. As described before this is improved by using \lstcpp{bcm2835_delayMicroseconds()} over builtin C++ sleep functions. Nevertheless, because of the nature of Linux scheduling, it can not be quaranteed that the thread will pause exactly the given delay every time. Linux scheduling is fair. This means every process gets its time on the CPU. If a process was paused and needs to wake up again, it has to wait for the current process on the CPU to finish its time slice. For time relevant processes Linux provides a feature to bypass this behaviour. A process can be given a scheduling priority. When this process wants to wake up and a process with lower or no priority uses the CPU it is paused immediately and the new proccess does not need to wait. This still does not quarantee a fixed sleep time because there could always be a task with higher priority but it reduces the risk of waiting.\cite{faschingbauer_realtime_nodate}\p
%
The scheduling priority can be changed using \lstcpp{pthread_setschedparam()} from the \textbf{PThread} library (Listing \ref{lst:software:spi:rt}). It takes a priority between $1$ and $99$, where $99$ is the highest priority and $1$ is the lowest. A priority of $1$ or $2$ is usually sufficient because most processes do not have any scheduling priority.\cite{noauthor_pthread_setschedparam3_nodate}
%
\begin{mdframed}
\begin{lstlisting}[caption=Example for creating a thread with realtime priority, label=lst:software:spi:rt]
std::thread* Speaker::run_thread() {
  loop = new std::thread(&Speaker::run, this);
  pthread_t id = (pthread_t)(loop->native_handle());

  sched_param sched_params = { 2 };
  pthread_setschedparam(id, SCHED_FIFO, &sched_params);

  return loop;
}
\end{lstlisting}
\end{mdframed}
%
All threads used in the program are started with a priority of $1$ or $2$ as shown in listing \ref{lst:software:spi:rt}.