\subsection{SPI (Audio output)}

\subsubsection*{SPI interface}

As described before the samplingrate of the SPI output should be at least $100kHz$. This means every $10us$ one packet has to be submitted. The Linux OS for the Raspberry Pi provides a SPI implementation wich can be accessed via C++ or Python. After putting a spi write into a loop without any pause or other calculation it became noticeable that this implementation is only able to send one package every $50\mu s$ to $80\mu s$. This problem can be solved with the \textbf{bcm2835} C library.\cite{mccauley_bcm2835_nodate} This library bypasses the linux drivers and directly accesses the bcm2835 SOC from the Raspberry Pi. It provides interfaces for GPIO pins, PWM and SPI as well as \lstinline{bcm2835_delayMicroseconds()} function wich is much more accurate than the builtin C++ functions.\p
%
The SPI configuration is put into the HAL class \lstinline{SPI}. See listing \dots.\p
\dots \textit{code explanation} \dots\p
%
The \lstinline{SPI} class provides the method \lstinline{write()} which takes a byte array and writes it on the SPI bus (Listing \dots). The method \lstinline{transfer()} passes through the function \lstinline{bcm2835_spi_transfernb()} from the \textbf{bcm2835} library. This function takes two buffer. One contains the data wich should be transmitted. The second one is used to save the received data.\p
\dots \textit{code explanation ?} \dots\p

\subsubsection*{Transmit audio}

The audio transmission over SPI is done in the class \lstinline{Speaker}. The method \lstinline{Speaker::run()} creates a loop in wich the next audio sample is fetched from the \lstinline{Speaker::samples} queue and transmitted over SPI. After the transmission the loop is paused to reach the right samplingrate. The sleep time is calculated dynamically depending on the time the sending of the data took. The coresponding code is shown in listing \dots.\p
\dots \textit{code explanation} \dots\p

\subsubsection*{Linux Realtime}

Because the signal is split into a fixed samplingrate, timing is really important for this task. As described before this is improved by using \lstinline{bcm2835_delayMicroseconds()} over builtin C++ sleep functions. Nevertheless, because of the nature of Linux scheduling, it can not be quaranteed that the thread will pause exactly the given delay every time. Linux scheduling is fair. This means every process gets its time on the CPU. If a process was paused and needs to wake up again it has to wait for the current process on the cpu to finish it's time slice. For time relevant processes Linux provides a feature to bypass this behaviour. A process can be given a scheduling priority. Now when this process wants to wake up and a process with a lower or no priority uses the CPU it is paused immediately and the proccess does not need to wait. This still don't quarantees a fixed sleep time because there could always be a task with higher priority but it reduces the risk of waiting.\p
%
The scheduling priority can be changed using \lstinline{pthread_setschedparam()} from the \textbf{PThread} library (Listing \dots). It takes a priority between $1$ and $99$, where $99$ is the highest priority and $1$ is the lowest. A priority of $1$ or $2$ is usually enough because most processes don't have any scheduling priority.