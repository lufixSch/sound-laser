\subsection{Modulation}
%
The modulation process is realised in \lstcpp{AudioProcessor::run()} (Listing \ref{lst:software:mod:loop}). To make switching between modulation techniques easier the methods for calculation the modulation itself are provided by the \lstcpp{Modulator} class.\p
%
\begin{mdframed}
\begin{lstlisting}[caption=Audio processing loop, label=lst:software:mod:loop]
void AudioProcessor::run() {
  std::cout << "Run Audio Processor\n";

  const auto& speaker = Speaker::instance();
  Modulator mod(sampling_rate, frame_size, speaker->sampling_rate, 40000);

  while (true) {
    const auto& buffer = samples.pop();

    for (const auto t : mod.time) {
      const auto sig = mapValue(buffer.at(floor(t * sampling_rate)));
      const auto sample = mod.AM(sig, t, 0.5f, 0.8f); // AM
      // const auto sample = mod.FM(sig, t, 1.0f, 0.15f);   // FM
      speaker->samples.push(speaker->mapSample(sample));
    }
  }
}
\end{lstlisting}
\end{mdframed}
%
First the samples captured from the audio input are fetched from the \lstcpp{AudioProcessor::samples} queue. As the signal recorded with ALSA is a regular audio signal the sampling rate goes up to $48\,kHz$ depending on the configuration. The resulting signal however should have a sampling rate above $100\,kHz$. Therefore the signal needs to be resampled. This can be realised with different forms of interpolation. In this example the zero order hold variant is used.\p
%
As the \lstcpp{Modulator} class is instantiated a time vector with the target sampling rate and a size corresponding to the number of recorded samples is created. The modulation is calculated for every sample by iterating over the time vector.\p
%
Listing \ref{lst:software:mod:am} and \ref{lst:software:mod:fm} show the C++ implementations of the AM and FM explained in section \secref{sec:theory:mod}.
%
\begin{mdframed}
\begin{lstlisting}[caption=Amplitude modulation, label=lst:software:mod:am]
float Modulator::AM(float signal, float t, float U0, float m) {
  float c = sin(carrier * t);
  return U0 * (1 + m * signal) * c;
}
\end{lstlisting}
\end{mdframed}
%
\begin{mdframed}
\begin{lstlisting}[caption=Frequency modulation, label=lst:software:mod:fm]
float Modulator::FM(float signal, float t, float U0, float m) {
  float w0 = carrier;
  return U0 * sin(w0 * (1 + m * signal) * t);
}
\end{lstlisting}
\end{mdframed}